<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>⚡ SVG 俄罗斯方块</title>
<style>
    html,body{margin:0;height:100%;overflow:hidden;background:#111;font-family:system-ui,sans-serif;}
    #game{width:100vw;height:100vh;display:block;background:radial-gradient(circle at 30% 30%,#2d2d2d,#111);}
    text{pointer-events:none;}
    .info{font-size:18px;fill:#fff;}
    .pause{font-size:48px;fill:#fffb00;}
    /* ----------------- 新增按钮样式 ----------------- */
    .homeBtn{
        position:fixed;               /* 固定在视口左上角 */
        top:12px; left:12px;
        background:#fff;              /* 白底 */
        color:#000;                   /* 黑字 */
        border:none;
        border-radius:8px;            /* 圆角 */
        padding:4px 10px;             /* 小一点的内边距 */
        font-size:14px;               /* 小一点的字体 */
        cursor:pointer;
        opacity:0.9;
        transition:opacity .2s;
        z-index:999;                  /* 保证在 SVG 之上 */
    }
    .homeBtn:hover{opacity:1;}
</style>
</head>
<body>



<svg id="game" viewBox="0 0 320 640"></svg>

<script>
(()=>{

/* ---------- 常量与全局变量 ---------- */
const SVG_NS = "http://www.w3.org/2000/svg";
const COLS = 10, ROWS = 20;          // 井字格子
const CELL = 30;                     // 每格像素大小
const COLORS = [                    // 7 种方块颜色（加上透明占位）
    "#ff0a54","#ff477e","#ff7096","#ff85a1",
    "#ff9a8b","#ffb6b9","#c8c8c8"
];
const SHAPES = [                    // 7 种形状的 4×4 位图（0‑15 行列）
// I
[[0,0,0,0],
 [1,1,1,1],
 [0,0,0,0],
 [0,0,0,0]],
// J
[[1,0,0],
 [1,1,1],
 [0,0,0]],
// L
[[0,0,1],
 [1,1,1],
 [0,0,0]],
// O
[[1,1],
 [1,1]],
// S
[[0,1,1],
 [1,1,0],
 [0,0,0]],
// T
[[0,1,0],
 [1,1,1],
 [0,0,0]],
// Z
[[1,1,0],
 [0,1,1],
 [0,0,0]]
];
let board = [];                     // 20×10 的颜色索引（-1 = 空）
let current = null;                 // 正在下落的块
let intervalId = null;              // 主循环计时器
let speed = 800;                    // 初始掉落间隔（ms）
let score = 0, lines = 0, level = 1;
let paused = false;
let gameOver = false;

/* ---------- SVG 初始化 ---------- */
const svg = document.getElementById('game');
svg.setAttribute('width', COLS*CELL);
svg.setAttribute('height', ROWS*CELL);

// 预留 2 个层级：网格层、特效层
const gridGroup = document.createElementNS(SVG_NS,'g');
const pieceGroup = document.createElementNS(SVG_NS,'g');
const particleGroup = document.createElementNS(SVG_NS,'g');
svg.append(gridGroup, pieceGroup, particleGroup);

// 信息文字
const info = document.createElementNS(SVG_NS,'text');
info.setAttribute('x',5);
info.setAttribute('y',20);
info.setAttribute('class','info');
gridGroup.appendChild(info);

// 暂停文字（隐藏/显示）
const pauseText = document.createElementNS(SVG_NS,'text');
pauseText.setAttribute('x',COLS*CELL/2);
pauseText.setAttribute('y',ROWS*CELL/2);
pauseText.setAttribute('text-anchor','middle');
pauseText.setAttribute('class','pause');
pauseText.textContent = "PAUSED";
pauseText.style.display = "none";
svg.appendChild(pauseText);

/* ---------- 工具函数 ---------- */
function initBoard(){
    board = Array.from({length:ROWS},()=>Array(COLS).fill(-1));
}
function drawBoard(){
    // 清空后重新绘制所有已固定的方块
    pieceGroup.innerHTML='';
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            const colIdx = board[r][c];
            if(colIdx>=0){
                drawCell(c,r,COLORS[colIdx]);
            }
        }
    }
}
function drawCell(col,row,color,alpha=1){
    const rect = document.createElementNS(SVG_NS,'rect');
    rect.setAttribute('x',col*CELL);
    rect.setAttribute('y',row*CELL);
    rect.setAttribute('width',CELL-1);   // 留 1px 空隙形成网格感
    rect.setAttribute('height',CELL-1);
    rect.setAttribute('fill',color);
    rect.setAttribute('fill-opacity',alpha);
    rect.setAttribute('stroke','#333');
    rect.setAttribute('stroke-width','1');
    pieceGroup.appendChild(rect);
}
function rotate(shape){
    const N = shape.length;
    const res = Array.from({length:N},()=>Array(N).fill(0));
    for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
            res[c][N-1-r] = shape[r][c];
        }
    }
    return res;
}
function canPlace(shape,x,y){
    const N = shape.length;
    for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
            if(shape[r][c]){
                const yy = y+r, xx = x+c;
                if(xx<0||xx>=COLS||yy>=ROWS) return false;
                if(yy>=0 && board[yy][xx]!=-1) return false;
            }
        }
    }
    return true;
}

/* ---------- 产生新块 ---------- */
function spawn(){
    const idx = Math.floor(Math.random()*SHAPES.length);
    const raw = SHAPES[idx];
    const shape = raw.map(row=>row.slice()); // 深拷贝
    const color = COLORS[idx];
    const piece = {
        shape,
        x: Math.floor(COLS/2) - Math.ceil(shape[0].length/2),
        y: -shape.length, // 在可视区上方出现
        color,
        idx
    };
    if(!canPlace(piece.shape,piece.x,piece.y)){
        // 生成失败 → 游戏结束
        gameOver = true;
        clearInterval(intervalId);
        showGameOver();
        return;
    }
    current = piece;
    drawCurrent();
}

/* ---------- 绘制当前块 ---------- */
function drawCurrent(){
    // 只绘制当前块（不清除已有固定块）
    // 为避免叠加，先把前一次的临���块全部移除
    const temps = pieceGroup.querySelectorAll('.temp');
    temps.forEach(t=>t.remove());
    const {shape,x,y,color}=current;
    const N = shape.length;
    for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
            if(shape[r][c]){
                const cx = x + c;
                const cy = y + r;
                if(cy>=0){
                    const rect = document.createElementNS(SVG_NS,'rect');
                    rect.setAttribute('x',cx*CELL);
                    rect.setAttribute('y',cy*CELL);
                    rect.setAttribute('width',CELL-1);
                    rect.setAttribute('height',CELL-1);
                    rect.setAttribute('fill',color);
                    rect.setAttribute('fill-opacity','0.8');
                    rect.setAttribute('stroke','#222');
                    rect.setAttribute('stroke-width','1');
                    rect.classList.add('temp');
                    pieceGroup.appendChild(rect);
                }
            }
        }
    }
}

/* ---------- 方块落下 ---------- */
function step(){
    if(paused||gameOver) return;
    if(!current){ spawn(); return; }

    if(canPlace(current.shape, current.x, current.y+1)){
        current.y += 1;
        drawCurrent();
    }else{
        // 块落定，写入 board
        const {shape,x,y,color,idx}=current;
        const N = shape.length;
        for(let r=0;r<N;r++){
            for(let c=0;c<N;c++){
                if(shape[r][c]){
                    const yy = y+r;
                    const xx = x+c;
                    if(yy>=0){
                        board[yy][xx]=idx;
                    }
                }
            }
        }
        current=null;
        clearLines();
        drawBoard(); // 重绘所有固定块
    }
}

/* ---------- 行消除 ---------- */
function clearLines(){
    let cleared = 0;
    for(let r=ROWS-1;r>=0;r--){
        if(board[r].every(v=>v!=-1)){
            // 产生粒子特效
            for(let c=0;c<COLS;c++){
                emitParticle(c,r,COLORS[board[r][c]]);
            }
            // 消除此行
            board.splice(r,1);
            board.unshift(Array(COLS).fill(-1));
            cleared++;
            r++; // 检查新落来的行
        }
    }
    if(cleared){
        lines += cleared;
        score += (cleared===1?100: cleared===2?300: cleared===3?500:800);
        if(lines>=level*10){
            level++;
            speed = Math.max(100, speed-100);
            clearInterval(intervalId);
            intervalId = setInterval(step, speed);
        }
    }
}

/* ---------- 粒子特效 ---------- */
function emitParticle(col,row,color){
    const p = document.createElementNS(SVG_NS,'circle');
    const cx = (col+0.5)*CELL;
    const cy = (row+0.5)*CELL;
    p.setAttribute('cx',cx);
    p.setAttribute('cy',cy);
    p.setAttribute('r',4);
    p.setAttribute('fill',color);
    p.vx = (Math.random()-0.5)*2;
    p.vy = (Math.random()-0.5)*2;
    p.life = 30;
    particleGroup.appendChild(p);
    particles.push(p);
}
const particles = [];
function updateParticles(){
    for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.life--;
        if(p.life<=0){
            p.remove();
            particles.splice(i,1);
            continue;
        }
        const cx = parseFloat(p.getAttribute('cx'))+p.vx;
        const cy = parseFloat(p.getAttribute('cy'))+p.vy;
        p.setAttribute('cx',cx);
        p.setAttribute('cy',cy);
        p.setAttribute('fill-opacity', p.life/30);
    }
}

/* ---------- UI 更新 ---------- */
function updateInfo(){
    info.textContent = `Score: ${score}   Lines: ${lines}   Level: ${level}`;
}
function showGameOver(){
    const go = document.createElementNS(SVG_NS,'text');
    go.setAttribute('x',COLS*CELL/2);
    go.setAttribute('y',ROWS*CELL/2);
    go.setAttribute('text-anchor','middle');
    go.setAttribute('font-size','48');
    go.setAttribute('fill','#ff5555');
    go.textContent = "GAME OVER";
    svg.appendChild(go);
}

/* ---------- 键盘控制 ---------- */
document.addEventListener('keydown',e=>{
    if(e.repeat) return;
    if(gameOver) return;
    switch(e.code){
        case 'ArrowLeft':
            if(current && canPlace(current.shape,current.x-1,current.y)){
                current.x -= 1; drawCurrent();
            }
            break;
        case 'ArrowRight':
            if(current && canPlace(current.shape,current.x+1,current.y)){
                current.x += 1; drawCurrent();
            }
            break;
        case 'ArrowUp': // 旋转
            if(current){
                const rot = rotate(current.shape);
                if(canPlace(rot,current.x,current.y)){
                    current.shape = rot;
                    drawCurrent();
                }
            }
            break;
        case 'ArrowDown': // 软降
            if(current && canPlace(current.shape,current.x,current.y+1)){
                current.y += 1; drawCurrent();
            }
            break;
        case 'Space': // 硬降
            if(!current) break;
            while(canPlace(current.shape,current.x,current.y+1)){
                current.y += 1;
            }
            drawCurrent();
            step(); // 让它立即落定一次
            break;
        case 'KeyP': // 暂停
            paused = !paused;
            pauseText.style.display = paused ? 'block' : 'none';
            break;
        case 'KeyR': // 重新开始
            reset();
            break;
    }
});

/* ---------- 主循环 ---------- */
function tick(){
    updateInfo();
    updateParticles();
}
function start(){
    initBoard();
    drawBoard();
    intervalId = setInterval(step, speed);
    setInterval(tick, 30);
}
function reset(){
    clearInterval(intervalId);
    particleGroup.innerHTML='';
    particles.length = 0;
    paused = false;
    gameOver = false;
    pauseText.style.display = 'none';
    score = lines = level = 0;
    speed = 800;
    initBoard();
    drawBoard();
    current = null;
    intervalId = setInterval(step, speed);
}

/* ---------- 初始化并开始游戏 ---------- */
start();

})();
</script>
</body>
</html>